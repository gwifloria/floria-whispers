
### 第一个坑：类型定义到处重复

我有个前后端一体的 Monorepo 项目，理论上接口类型应该共用一份。但让 Claude Code 帮我做一个完整的前后端功能时，它会在前端和后端各生成一份类型定义。

这导致什么问题呢？后面改需求的时候，我得改好几个地方，而且 AI 经常改漏。

后来我跟它约定了一个规范：**定义一个核心的 CoreType 放在公共包里，前后端各自去继承、补充自己需要的字段**。

但这里我犯了一个错——我没有及时把这个约定写进 `CLAUDE.md`，结果过几天又出现类似的问题，AI 又忘了。

---

### 第二个坑：本地能跑，部署就炸

我在把 Express 和 Next.js 合并进 Turborepo 的时候，跟 AI 说我想把一些长时服务单独部署，比如邮件同步、接口轮询这种。

AI 看起来帮我做完了，本地测试也都能跑通。但一部署上去就出问题了——它把邮件同步的逻辑写在了 Next.js 的 API Routes 里。

问题在哪呢？我的前端是部署在 Vercel 的，那是 Serverless 环境，**函数执行有时间限制，不支持长连接**。这种长时任务根本跑不了。

后来我把这些服务迁到独立的 Node 服务，部署到 Render 才解决。

---

### 第三个坑：遇到错误无脑重试

有一次构建失败，AI 执行 `yarn build` 报错说 `dist/` 目录不存在。然后它就开始**连续重试同样的命令**，试了四五次，每次都是同样的错误。

它不会停下来分析：为什么 build 之后 dist 目录没生成？是不是构建本身就失败了？它只会机械地重复执行，直到我打断它。
![[Pasted image 20251202230924.png]]

---

### 第四个坑：头痛医头，不看全局

还有一次 Render 部署失败，报错说 `sharp` 需要 `node-gyp`。AI 的第一反应是在根目录加上 `node-gyp` 依赖。
![[Pasted image 20251203103104.png]]
我记得 sharp 是用来做图片优化的，部署到 render 的服务并不需要

我就问了一句：「后端服务为什么需要 sharp？」

它一查才发现：**后端服务根本不需要**。真正的问题是 `render.yaml` 里的 `yarn install` 会安装整个 Monorepo 的依赖，应该改成只安装 service 需要的包。

这就是典型的**头痛医头**——它看到报错就想着怎么消除这个报错，而不是退一步想这个依赖为什么会出现在这里。

另外补充一个功能点可以 csr 和 ssr 结合的问题，也是需要人去主导设计
![[Pasted image 20251130095602.png]]


---

### 第五个坑：用「偷懒方案」绕过问题

AI 有两个很危险的习惯：

**一是遇到 ESLint 报错就 disable**。比如 `exhaustive-deps` 报警，它不去分析依赖数组该怎么写，直接加一行 `eslint-disable-next-line` 就完事了。代码能跑，但埋了隐患。
![[Pasted image 20251202093617.png]]
**二是为了让构建通过，把敏感信息硬编码**。比如环境变量没配，构建会失败，它就把 token 直接写死在代码里当 fallback。正确做法应该是构建时检查环境变量，缺失就报错，而不是用默认值蒙混过关。
![[Pasted image 20251203110941.png]]
三是碰到测试用例通不过时，它会去直接修改测试用例……

---

### 我的反思

这些坑表面上看是 AI 的问题，但反过来想，**核心其实是我没把上下文传递清楚**。

用好 AI 最关键的一点，就是要把自己的上下文尽可能无 Gap 地提供给它——需求背景、技术约束、部署环境这些，你脑子里觉得「这不是显而易见的吗」，但 AI 不知道。

而**「组织上下文」这件事本身就是一个能力**，我觉得很多人其实不太擅长，包括我自己。前面踩的坑，本质上就是我没把隐性知识显性化——没说清楚部署环境是 Serverless，没及时把约定写成文档。

这个能力不光是跟 AI 协作需要，跟人协作也一样。我自己在这方面还在刻意练习，比如现在会把思考过程、做过的决策、踩过的坑都记录下来。这样不管是给 AI 还是给未来的自己，上下文都更完整。

---
现在我的 AI 至少在UI 设计上已经很懂我了
![[Pasted image 20251202224127.png]]