# 缓存优化实现计划

## 一、需求总结

| 序号  | 需求内容                                      |
| --- | ----------------------------------------- |
| 1   | AI 翻译自动开启缓存 - 使用 AI 翻译时自动使用缓存             |
| 2   | 非 AI 不走缓存 - Google/Microsoft 等免费翻译服务不使用缓存 |
| 3   | 第一期不支持配置 - 规则硬编码，无 UI 开关                  |
| 4   | 规则存在配置里 - 方便后续扩展                          |

## 二、当前代码分析

### 1. 现有缓存服务（services/cache.ts）

- 存储方式：使用 Dexie (IndexedDB) 存储
- 配置项：enabled（是否启用）、maxSize（最大大小，MB）、ttl（过期天数，天）
- 缓存键：SHA256 (text + provider + sourceLang + targetLang + metadata)
- 问题：基于 createdAt 淘汰（FIFO），非 LRU

### 2. 翻译流程（core/translate/translate-text.ts）

- 问题：完全未使用缓存服务，直接调用 translateWithQueue ()
- AI 判断逻辑：useAI = config.aiTranslate?.enabled && config.aiTranslate?.provider

### 3. 缓存配置（types/config.ts）

typescript

运行

```typescript
cache: {
  enabled: boolean     // 是否启用
  maxSize: number      // 最大大小 (MB)
  ttl: number          // 过期天数
}
```

## 三、实现方案

### 1. 配置扩展（为后续扩展预留）

#### 文件：apps/extension/src/types/config.ts

typescript

运行

```typescript
const cacheConfigSchema = z.object({
  enabled: z.boolean(),
  maxSize: z.number().min(0).max(1000),
  ttl: z.number().min(0).max(30),
  // 新增：AI 专用缓存策略
  aiOnly: z.boolean().optional().default(true),
})
```

#### 文件：apps/extension/src/core/config/constants.ts

typescript

运行

```typescript
// 在默认配置中添加
cache: {
  enabled: true,
  maxSize: 100,
  ttl: 7,
  aiOnly: true,  // 新增
}
```

### 2. 缓存服务升级为 LRU

#### 文件：apps/extension/src/services/cache.ts

typescript

运行

```typescript
// 1. 新增 lastUsed 字段到 TranslationCacheRecord
export interface TranslationCacheRecord {
  key: string
  translation: string
  createdAt: Date
  lastUsed: Date      // 新增
}

// 2. 升级数据库 schema，添加 lastUsed 索引
this.version(2).stores({
  translationCache: '&key, createdAt, lastUsed',
})

// 3. get() 方法在命中时更新 lastUsed
async get(context): Promise<string | null> {
  // ... 原有逻辑 ...
  if (record) {
    // 更新最后使用时间
    await this.db.translationCache.update(key, { lastUsed: new Date() })
    return record.translation
  }
  return null
}

// 4. enforceMaxSize() 改为按 lastUsed 排序淘汰
async enforceMaxSize() {
  // ... 原有逻辑 ...
  const entries = await this.db.translationCache.orderBy('lastUsed').toArray()
  // ... 淘汰逻辑 ...
}
```

### 3. 添加 AI 缓存策略检查

#### 文件：apps/extension/src/services/cache.ts

typescript

运行

```typescript
// 新增接口定义
interface CacheDecisionContext {
  isAI: boolean
}

// 新增缓存策略判断方法
async shouldUseCache(context: CacheDecisionContext): Promise<boolean> {
  const config = await this.getCacheConfig()
  if (!config.enabled) return false

  // aiOnly 模式下，只有 AI 翻译才使用缓存
  if (config.aiOnly && !context.isAI) {
    return false
  }

  return true
}
```

### 4. 在翻译流程中集成缓存

#### 文件：apps/extension/src/core/translate/translate-text.ts

typescript

运行

```typescript
import { getCacheService } from '@/services/cache'

export async function translateText(sourceText: string, config?: Config | null): Promise<string> {
  // ... 现有代码 ...

  const useAI = validConfig.aiTranslate?.enabled && validConfig.aiTranslate?.provider
  const cacheService = getCacheService()

  // 构建缓存上下文
  const cacheContext = {
    text: cleanSourceText,
    providerConfig: useAI
      ? { provider: validConfig.aiTranslate!.provider, model: validConfig.aiTranslate!.model }
      : { provider: validConfig.provider.provider },
    language: {
      sourceCode: sourceLang,
      targetCode: targetLang,
    },
  }

  // 检查是否应该使用缓存
  const shouldCache = await cacheService.shouldUseCache({ isAI: !!useAI })

  if (shouldCache) {
    // 尝试从缓存获取
    const cached = await cacheService.get(cacheContext)
    if (cached) {
      return cached
    }
  }

  // 调用翻译 API
  const translatedText = await translateWithQueue({ ... })

  // 保存到缓存
  if (shouldCache && translatedText) {
    await cacheService.set(cacheContext, translatedText)
  }

  return translatedText
}
```

## 四、修改文件清单

|文件路径|改动内容|
|---|---|
|apps/extension/src/types/config.ts|添加 aiOnly 字段到 cacheConfigSchema|
|apps/extension/src/core/config/constants.ts|默认配置添加 aiOnly: true|
|apps/extension/src/services/cache.ts|1. 添加 lastUsed 字段<br><br>2. 升级数据库 schema<br><br>3. LRU 淘汰逻辑<br><br>4. 添加 shouldUseCache () 方法|
|apps/extension/src/core/translate/translate-text.ts|集成缓存服务，AI 翻译走缓存|

## 五、实现步骤

### Step 1: 配置扩展

1. 在 `types/config.ts` 的 `cacheConfigSchema` 中添加 `aiOnly` 字段
2. 在 `core/config/constants.ts` 的默认配置中添加 `aiOnly: true`

### Step 2: 缓存服务 LRU 升级

1. 修改 `TranslationCacheRecord` 接口，添加 `lastUsed` 字段
2. 升级数据库 version，添加 `lastUsed` 索引
3. 修改 `get()` 方法，命中时更新 `lastUsed`
4. 修改 `set()` 方法，写入时同时设置 `createdAt` 和 `lastUsed`
5. 修改 `enforceMaxSize()` 方法，按 `lastUsed` 排序淘汰最久未用的

### Step 3: 添加缓存策略判断

1. 在 `CacheService` 中添加 `shouldUseCache(context)` 方法
2. 根据 `aiOnly` 配置和 `isAI` 参数决定是否使用缓存

### Step 4: 翻译流程集成

1. 在 `translateText()` 中导入并获取 `cacheService`
2. 构建 `cacheContext` 对象
3. 翻译前检查缓存
4. 翻译后保存到缓存

### Step 5: 测试验证

1. AI 翻译应命中 / 写入缓存
2. 非 AI 翻译不应使用缓存
3. LRU 淘汰逻辑正常工作
4. 缓存命中率统计正常

## 六、第二阶段：设置页面 Bug 测试

### 潜在问题点

|序号|问题|位置|严重程度|
|---|---|---|---|
|1|配置保存是全量覆盖，可能丢失新增配置|storage.ts|中|
|2|表单防抖 500ms，快速关闭页面可能丢失更改|use-general-settings-form.ts|中|
|3|AI 提供商切换时模型可能不同步|TranslationEngineSection.tsx|高|
|4|字幕配置路径复杂易出错|SubtitleSettings.tsx|低|
|5|翻译风格 ID 迁移在两处硬编码|ExpertSettings.tsx、AIEnhancementSection.tsx|低|
|6|translationNodeStyleSchema 无真正验证|config.ts:446|低|

### 测试清单

#### 通用设置 (General)

- 目标语言切换是否生效
- UI 语言切换是否生效
- 翻译引擎切换是否生效
- AI 增强开关是否生效
- AI 提供商切换后模型是否正确
- 翻译风格切换是否生效
- 悬浮翻译开关是否生效
- 划词翻译开关和触发方式是否生效
- 输入翻译开关是否生效

#### 显示设置 (Display)

- 显示模式 (replace/bilingual/mixed) 是否生效
- 样式预设切换是否生效
- 字体大小是否生效
- 文本颜色是否生效

#### 字幕设置 (Subtitle)

- 字幕开关是否生效
- 字幕位置是否生效
- 字幕字体设置是否生效

#### 专家设置 (Expert)

- 内置风格选择是否生效
- 自定义风格保存是否生效

### 测试方法

1. 开发模式测试：运行 `pnpm --filter "椰子翻译" dev`，打开设置页面
2. 逐项测试：修改每个配置，刷新页面检查是否持久化
3. 功能验证：在实际页面测试翻译功能是否按配置生效
4. 日志检查：在控制台观察配置读写日志

## 七、注意事项

1. 数据库迁移：从 version 1 升级到 version 2 时，需要为现有记录填充 `lastUsed = createdAt`
2. 性能考虑: `get()` 中更新 `lastUsed` 是额外的写操作，但对于翻译场景可接受
3. 向后兼容: `aiOnly` 设为 optional 并 default true，不影响现有用户