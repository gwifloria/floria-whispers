## 一、核心需求

|   |   |   |
|---|---|---|
|序号|需求内容|实现说明|
|1|AI 翻译自动走缓存|翻译流程中判断 useAI=true 时启用缓存逻辑|
|2|非 AI 翻译不走缓存|第一期硬编码限制，仅 AI 翻译触发缓存读写|
|3|复用现有缓存配置|直接使用 cache.enabled 作为缓存总开关|
|4|缓存淘汰升级为 LRU|新增 lastUsed 字段，按最近使用时间淘汰缓存|

## 二、现状分析

|   |   |   |   |
|---|---|---|---|
|组件 / 功能|对应文件|当前状态|待处理项|
|CacheService|services/cache.ts|✅ 基础缓存能力（Dexie + IndexedDB）|升级 LRU 淘汰策略|
|IndexedDB 存储|Dexie|✅ 工作正常|新增 lastUsed 索引（无需迁移）|
|缓存配置|types/config.ts|✅ 已定义 enabled/maxSize/ttl|无需修改，直接复用|
|translateText()|core/translate/translate-text.ts|❌ 未集成缓存逻辑|接入 CacheService，实现 AI 翻译缓存|

## 三、修改文件清单

|   |   |
|---|---|
|文件路径|核心改动|
|apps/extension/src/services/cache.ts|1. 新增 lastUsed 字段支持 LRU 2. 调整 Schema 新增 lastUsed 索引 3. 实现 LRU 淘汰逻辑（读取更新时间、按时间淘汰）|
|apps/extension/src/core/translate/translate-text.ts|1. 导入 CacheService2. 硬编码判断 AI 翻译缓存条件3. 翻译前读取缓存、翻译后写入缓存|

## 四、实现步骤

### Phase 1：缓存服务 LRU 升级

1. 扩展 `TranslationCacheRecord` 接口，添加 `lastUsed` 字段；
    
2. 在 v1 Schema 中新增 `lastUsed` 索引（无需版本迁移）；
    
3. 修改 `get()` 方法，缓存命中时更新 `lastUsed`；
    
4. 修改 `set()` 方法，写入缓存时初始化 `lastUsed`；
    
5. 重构 `enforceMaxSize()`，改为按 `lastUsed` 执行 LRU 淘汰。
    

### Phase 2：翻译流程集成缓存

1. 在 `translateText()` 中导入 `getCacheService`；
    
2. 计算缓存条件 `shouldCache = cache.enabled && useAI`；
    
3. 翻译前构建缓存上下文，尝试读取缓存（命中则直接返回）；
    
4. 翻译成功后，若缓存条件满足则写入缓存。
    

### Phase 3：测试验证 （应该会耗时最久）

1. **AI 缓存测试**：启用 AI 翻译，重复翻译相同文本，验证缓存命中（无重复 API 请求）；
    
2. **总开关测试**：设置 `cache.enabled: false`，验证所有翻译均不走缓存；
    
3. **LRU 淘汰测试**：填满缓存，验证最久未使用的记录被优先删除。
    

## 五、实现方案

### Step 1：缓存服务 LRU 策略升级

#### 文件路径：`apps/extension/src/services/cache.ts`

##### 1.1 扩展缓存记录接口（新增 lastUsed 字段）

```TypeScript
export interface TranslationCacheRecord {
  key: string
  translation: string
  createdAt: Date
  lastUsed: Date      // 新增：用于 LRU 淘汰的最后使用时间}
```

##### 1.2 数据库 Schema 调整（无需迁移）

```TypeScript
constructor() {super('congcong-translate-cache')// 直接在 v1 中添加 lastUsed 索引（缓存从未被使用，无需版本迁移）this.version(1).stores({
    translationCache: '&key, createdAt, lastUsed',  // 新增 lastUsed 索引})}
```

##### 1.3 缓存读取时更新 lastUsed（LRU 核心）

```TypeScript
async get(context: TranslationCacheContext): Promise<string | null> {const cacheConfig = await this.getCacheConfig()if (!cacheConfig.enabled) return nullawait this.ready
  const key = this.generateCacheKey(context)try {const cached = await this.db.translationCache.get(key)if (cached?.translation) {this._hits++// LRU 核心：命中后更新最后使用时间await this.db.translationCache.update(key, { lastUsed: new Date() })return cached.translation
    }this._misses++return null} catch (error) {
    log.error({ err: error }, 'Failed to read translation cache')this._misses++return null}}
```

##### 1.4 缓存写入时初始化 lastUsed

```TypeScript
async set(context: TranslationCacheContext, translation: string): Promise<void> {if (!translation) returnconst cacheConfig = await this.getCacheConfig()if (!cacheConfig.enabled) returnawait this.ready
  const key = this.generateCacheKey(context)const now = new Date()try {await this.db.translationCache.put({
      key,
      translation,
      createdAt: now,
      lastUsed: now,  // 初始化最后使用时间})await this.enforceMaxSize(cacheConfig)} catch (error) {
    log.error({ err: error }, 'Failed to write translation cache')}}
```

##### 1.5 缓存容量控制改为 LRU 淘汰

```TypeScript
private async enforceMaxSize(cacheConfig: CacheConfig): Promise<void> {if (cacheConfig.maxSize <= 0) returnconst maxBytes = cacheConfig.maxSize * 1024 * 1024// LRU 核心：按 lastUsed 升序排序（最久未使用的记录在前）const entries = await this.db.translationCache.orderBy('lastUsed').toArray()const sizes = entries.map(entry => this.estimateEntrySize(entry))let totalBytes = sizes.reduce((acc, size) => acc + size, 0)if (totalBytes <= maxBytes) return// 从最久未使用的记录开始删除，直到缓存容量达标for (let i = 0; i < entries.length && totalBytes > maxBytes; i++) {try {await this.db.translationCache.delete(entries[i].key)
      totalBytes -= sizes[i]} catch (error) {
      log.error({ err: error }, 'Failed to enforce cache size limit')break}}}
```

### Step 2：翻译流程集成缓存逻辑

#### 文件路径：`apps/extension/src/core/translate/translate-text.ts`

```TypeScript
import { getCacheService } from '@/services/cache'export async function translateText(sourceText: string, config?: Config | null): Promise<string> {// ... 保留原有配置加载、文本清洗、语言检测等逻辑 ...const cleanSourceText = sourceText.replace(/\u200B/g, '').trim()const validConfig = (config ?? globalConfig) as Config

  const sourceLang = getLanguageByFranc(cleanSourceText)const targetLang = validConfig.language.targetCode

  // 相同语言直接返回，无效目标语言抛错if (sourceLang === targetLang) return sourceText
  if (!targetLang) throw new Error('Invalid target language code')// 判断是否使用 AI 翻译const useAI = validConfig.aiTranslate?.enabled && validConfig.aiTranslate?.provider

  // ========== 新增：缓存逻辑 ==========// 第一期硬编码规则：仅 AI 翻译且缓存总开关开启时使用缓存const shouldCache = validConfig.cache.enabled && useAI
  const cacheService = shouldCache ? getCacheService() : null// 构建缓存上下文（仅缓存生效时）const cacheContext = shouldCache ? {
    text: cleanSourceText,
    providerConfig: {
      provider: validConfig.aiTranslate!.provider,
      model: validConfig.aiTranslate!.model,},
    language: {
      sourceCode: sourceLang,
      targetCode: targetLang,},} : null// 缓存读取：命中则直接返回结果if (cacheService && cacheContext) {const cached = await cacheService.get(cacheContext)if (cached) {return cached
    }}// ========== 缓存读取结束 ==========// 原有翻译 API 调用逻辑const extraParams = useAI ? { model: validConfig.aiTranslate!.model } : {}const contextEnhancementEnabled = useAI && validConfig.ai?.contextEnhancement
  const pageContext = contextEnhancementEnabled ? collectPageContext() : undefinedlet translatedText = await translateWithQueue({
    text: cleanSourceText,
    fromLang: sourceLang,
    toLang: targetLang,
    provider: useAI ? validConfig.aiTranslate!.provider : validConfig.provider.provider,
    pageContext,...extraParams,})// 原有翻译结果处理逻辑
  translatedText = translatedText.trim()const isSame = isSameText(cleanSourceText, translatedText)const result = isSame ? '' : translatedText

  // ========== 新增：缓存写入 ==========// 翻译成功后写入缓存（仅缓存生效时）if (cacheService && cacheContext && result) {await cacheService.set(cacheContext, result)}// ========== 缓存写入结束 ==========return result
}
```

## 六、测试场景与预期结果

|   |   |   |
|---|---|---|
|测试场景|操作步骤|预期结果|
|缓存总开关关闭（cache.enabled: false）|任意翻译类型（AI / 非 AI）|所有翻译均发起 API 请求，无缓存读写|
|缓存开启 + AI 翻译|1. 首次翻译文本 A2. 再次翻译文本 A|1. 发起 API 请求，结果写入缓存2. 读取缓存返回，无 API 请求|
|缓存开启 + 非 AI 翻译（Google）|1. 首次翻译文本 B2. 再次翻译文本 B|两次均发起 API 请求，无缓存读写|

## 七、注意事项

1. **快速回滚**：只需将 `cache.enabled` 设为 `false`，即可完全禁用缓存逻辑，恢复原有翻译流程；
    
2. **缓存键稳定性**：`generateCacheKey()` 已包含文本、服务商、语言等维度，确保相同翻译场景生成唯一键，避免缓存混乱。
    

  

TODO

- 添加一个清除缓存的按钮
    
- 开发环境也可以考虑添加一个实时监控indexdb的面板