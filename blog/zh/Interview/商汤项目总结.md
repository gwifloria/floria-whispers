我来帮你整理美化这个面试文档：

---

# 前端项目技术亮点整理

## 一、Vehicle Monitoring Web

### 1. createSharedComposable - Vue3 共享状态模式

```ts
// src/utils/createSharedComposable.ts
export function createSharedComposable<F extends (...args: any[]) => any>(composable: F) {
  let subscribers = 0;
  let state: T | undefined;
  let scope: EffectScope | undefined;

  const dispose = () => {
    if (scope && --subscribers <= 0) {
      scope.stop();
      state = scope = undefined;
    }
  };

  return (...args: any[]) => {
    subscribers++;
    if (!state) {
      scope = effectScope(true);
      state = scope.run(() => composable(...args));
    }
    onScopeDispose(dispose);
    return state;
  };
}
```

**面试话术：**

- 实现了 Vue3 RFC-0041 的 EffectScope 共享状态模式
- 多组件共享同一个 composable 实例，避免重复创建定时器/监听器
- 自动管理订阅者计数，最后一个组件卸载时自动释放内存
- 应用场景：`useSharedCurrentTime`，全应用共享一个时间更新定时器

---

### 2. useFetch 多租户工厂模式

```ts
// src/api/index.ts
export function createTenantUseFetch(tenantType: TenantType) {
  return createFetch({
    baseUrl: apiPrefix[tenantType],  // /api, /api/fengxi, /api/wuxi
    options: {
      async beforeFetch(ctx) {
        return { options: appendBeforeFetchOptions(ctx, tenantType) };
      },
    },
  });
}
```

**面试话术：**

- 基于 `@vueuse/core` 的 `createFetch` 二次封装
- 工厂函数为每个租户创建独立实例，自动绑定不同 baseUrl 和 Token
- `beforeFetch` 拦截器统一注入 Authorization 和自定义 header
- 组件使用只需 `import { useFetch } from '@/api/lingangApi'`

---

### 3. Token 刷新机制（重试 + 定时）

```ts
// src/composable/useRefreshToken/index.ts
onError(() => {
  if (currentRetry.value < 3) {
    setTimeout(request, 3000);  // 失败重试：3次，间隔3秒
  }
});

useIntervalRunner(updateToken);  // 定时刷新：每5天
```

**面试话术：**

- 失败自动重试（最多 3 次，间隔 3 秒）
- 集成 `useInterval` 实现 5 天周期自动刷新
- 使用 `p-defer` 实现 Promise 延迟 resolve，支持异步等待初始化完成
- App 入口阻塞渲染，确保 Token 就绪后才渲染子组件

---

### 4. DigitalScroll 数字滚动动画

```ts
// src/components/DigitalScroll/index.vue - 队列动画
const changeList = reactive([]);

const doChange = () => {
  const current = changeList.shift();
  if (current) {
    setTimeout(() => {
      list.value = current.value;
      doChange();
    }, current.timeout);
  }
};

// src/components/DigitalScroll/SingleDigital.vue - GSAP 动画
gsap.to(top, {
  duration: 1,
  value: -1 * digitalHeight * val,
  ease: 'power1.out',
});
```

**面试话术：**

- 队列模式处理连续数字变化，保证动画顺序执行
- 数字位数变化时先用 0 填充再显示真实值，实现平滑过渡
- 集成 GSAP 实现高性能单数字滚动动画
- 正确处理动画取消（`gsap.killTweensOf`）

---

### 5. BMap 百度地图组件 - Render Props 模式

```tsx
// src/components/baidumap/BMap.vue
return () => (
  <div class="map-container">
    <div ref={domRef} class={clazz}></div>
    {mapIsReady.value && slots.default?.(cxt)}
    {!mapIsReady.value && <div class="map-loading">正在初始化...</div>}
  </div>
);
```

**面试话术：**

- 使用 TSX 语法实现 Render Function
- Render Props 模式：通过 slot 传递地图实例给子组件
- 条件渲染处理加载状态
- 支持暗色主题配置

---

### 6. Vite 工程化配置

```ts
// vite.config.ts
AutoImport({
  imports: ['vue', 'vue-router', '@vueuse/core'],
  resolvers: [ElementPlusResolver({ importStyle: 'sass' })],
}),

Components({
  resolvers: [ElementPlusResolver({ importStyle: 'sass' })],
}),

css: {
  preprocessorOptions: {
    scss: {
      additionalData: `@use "@/style/element/index.scss" as *;`,
    },
  },
},
```

**面试话术：**

- `unplugin-auto-import`：Vue/VueUse API 全局自动导入，无需手动 import
- `unplugin-vue-components`：组件自动注册
- SCSS 全局变量注入：Element Plus 主题定制无需每个文件导入
- 开发服务器代理配置

---

### 7. TypeScript 高级类型

```ts
// 枚举 + 类型映射
export enum TenantType { lingang, wuxi, fengxi }
export type TenantTypes = keyof typeof TenantType;

// 映射类型
export type TokenMap = {
  [k in TenantTypes]?: {
    token?: string;
  };
};

// 泛型约束
const useRefreshTokenApi = <T>(tenantType: MaybeRef<string>) => {
  return useFetch<T>(url, { immediate: false }).json();
};
```

**面试话术：**

- `keyof typeof` 从枚举生成联合类型，避免重复定义
- `in` 关键字实现映射类型
- 泛型约束 + `MaybeRef` 支持响应式和普通值参数

---

### 8. Pinia 状态管理

```ts
// src/stores/auth.ts
getters: {
  isFetchingToken: (state) => {
    let r = 1;
    tenants.forEach((key) => {
      r = r & (state.tokenFetchingMap[key] ? 0 : 1);  // 位运算
    });
    return !r;
  },
  
  getTokens: (state) => (tenant) => state.tokens[tenant],  // 函数式 getter
},
```

**面试话术：**

- 多租户 Token 独立存储
- 追踪每个租户的 Token 获取状态（loading）
- 函数式 getter 支持参数化查询
- 使用 `cloneDeep` 防止默认状态污染

---

## 二、大文件分片上传系统

### 为什么需要分片上传？

**问题背景：**

运维系统需要上传 OTA 固件包，文件通常在几百 MB 到几 GB。

**传统单次上传的问题：**

|问题|说明|
|---|---|
|浏览器内存溢出|一次性读取大文件会占用大量内存|
|网络不稳定|上传中断需要从头开始，用户体验极差|
|服务端超时|长时间传输容易触发网关超时|
|无进度反馈|用户不知道上传到哪了|

**解决方案：** 将大文件切成固定大小（如 5MB）的分片，逐个上传，支持断点续传。

---

### 整体架构设计

```
┌─────────────────────────────────────────────────────────────┐
│                      useProvide (入口)                       │
│  - 创建 Worker 实例                                          │
│  - 初始化队列和 Runner                                        │
│  - 页面离开确认拦截                                           │
└─────────────────────────────────────────────────────────────┘
                                │
            ┌───────────────────┼───────────────────┐
            ▼                   ▼                   ▼
┌─────────────────┐   ┌─────────────────┐   ┌─────────────────┐
│   Web Worker    │   │ UploadFileQueue │   │  UploadRunner   │
│  (分片+MD5计算)  │   │   (任务队列)     │   │ (并发控制执行器) │
└─────────────────┘   └─────────────────┘   └─────────────────┘
            │                   │                   │
            └───────────────────┼───────────────────┘
                                ▼
┌─────────────────────────────────────────────────────────────┐
│                      UploadFile (核心)                       │
│  - 管理单个文件的元数据和分片状态                              │
│  - 跟踪已上传分片 Set<number>                                 │
│  - 计算上传进度                                               │
└─────────────────────────────────────────────────────────────┘
```

---

### 核心流程详解

#### 1. Web Worker 处理分片（避免主线程卡顿）

**痛点：** 大文件分片 + MD5 计算是 CPU 密集型操作，在主线程执行会导致页面卡死。

```ts
// worker.ts - 独立线程
onmessage = (e) => {
  const file: File = e.data;
  generateSlicesAndMd5MetaData(file).then((fileMetaData) => {
    postMessage(fileMetaData);
  });
};

// 主线程 - 不阻塞 UI
const worker = new GenerateFileChunksWorker();
worker.postMessage(file);
worker.onmessage = (ev) => {
  fileMetaDataDispatch(ev.data);
};
```

**面试亮点：**

- Vite 原生支持 `?worker` 语法，无需额外配置
- 组件卸载时调用 `worker.terminate()` 释放资源

---

#### 2. 分片生成 + SparkMD5 增量计算

```ts
const generateChunks = async (file: File, chunks: number, chunkSize: number) => {
  const spark = new SparkMD5.ArrayBuffer();  // 增量哈希计算器
  const slices = new Array<SliceMetaData>(chunks);
  const freader = new FileReader();

  freader.onload = (e) => {
    const chunkArrayBuffer = e.target.result as ArrayBuffer;

    // 1. 存储当前分片元数据
    const chunkMd5 = SparkMD5.ArrayBuffer.hash(chunkArrayBuffer);
    slices[currentChunk] = { start, end, size, blob, md5: chunkMd5 };

    // 2. 增量追加到整体 MD5 计算
    spark.append(chunkArrayBuffer);

    // 3. 继续下一片
    if (++currentChunk < chunks) {
      readChunk();
    } else {
      resolve({ md5: spark.end(), slices });
    }
  };

  function readChunk() {
    const blob = file.slice(start, end);
    freader.readAsArrayBuffer(blob);
  }

  readChunk();
};
```

**关键点：**

- `File.prototype.slice()` 原生切片，不占额外内存
- SparkMD5 支持增量计算，边读边算，最后 `spark.end()` 得到完整文件 MD5
- 每个分片单独计算 MD5，用于服务端校验

---

#### 3. 断点续传实现

**原理：** 服务端返回已上传分片列表，客户端跳过这些分片。

```ts
// 更新本地已上传集合
export const updateToLatestUploadedSetWithServerData = (serverSlices, uploadFile) => {
  const uploadedSet = serverSlices.reduce((set, slice) => {
    if (slice.is_uploaded) {
      set.add(Number(slice.part_number));
    }
    return set;
  }, new Set<number>());

  uploadFile.setUploadedBySliceNumberSet(uploadedSet);
};

// 获取下一个待上传分片（跳过已完成的）
getNextSliceNumber() {
  let i = 0;
  while (++i <= count) {
    if (this.uploaedSliceNumberSet.has(i) === false) {
      return i;
    }
  }
  return invalidSliceNumber;
}
```

**面试亮点：**

- 使用 `Set<number>` 存储已上传分片，O(1) 查找
- 网络中断后重新进入页面，服务端告知进度，无缝续传

---

#### 4. 并发上传控制

```ts
const maxRunningWorkers = 3;  // 最大并发数

const run = () => {
  if (queue.size() > 0) {
    if (++runningWorkers <= maxRunningWorkers) {
      (async function uploadSlice() {
        const queueItem = queue.pull();
        try {
          await startUpload(queueItem);
        } finally {
          runningWorkers--;
        }
      })();
    }
  }
  raf = requestAnimationFrame(run);
};
```

**设计考量：**

- 限制并发数为 3，避免浏览器连接数限制（Chrome 同域 6 个）
- 使用 `requestAnimationFrame` 轮询队列，比 `setInterval` 更节能
- 支持 `abort()` 取消单个文件或全部任务

---

### 技术亮点总结

|问题|解决方案|技术点|
|---|---|---|
|大文件阻塞主线程|Web Worker 独立线程处理|Vite worker 语法、postMessage|
|内存占用过高|File.slice 流式切片|Blob API、FileReader|
|完整性校验|SparkMD5 增量计算|整体 MD5 + 单片 MD5|
|网络中断重传|服务端返回已上传列表|Set 集合快速查找|
|多文件并发|队列 + 并发数控制|requestAnimationFrame 轮询|
|组件间通信|自研事件调度器|发布订阅模式|
|用户体验|页面离开拦截确认|beforeunload 事件|

---

### 面试问答准备

**Q: 为什么用 SparkMD5 而不是 crypto.subtle？**

SparkMD5 支持增量计算，可以边读边算。crypto.subtle 需要一次性传入完整数据，大文件会爆内存。

**Q: 分片大小如何确定？**

我们用 5MB。太小导致请求数过多，太大单片失败重传代价高。5MB 是实践中的平衡点。

**Q: 如何保证分片顺序？**

每个分片携带 `part_number`，服务端按序号存储，最后合并。客户端只需保证所有分片上传完成。

**Q: 并发数为什么是 3？**

浏览器对同域名有连接数限制（Chrome 6 个），留一部分给其他请求。3 是实践中较优的平衡。

**Q: 秒传是怎么实现的？**

上传前先把整体 MD5 发给服务端，服务端查库，如果已存在相同 MD5 的文件，直接返回成功，跳过实际上传。

---

## 三、WebSocket 跨框架封装库

### 简介

跨框架的 WebSocket 库，为 React 和 Vue 提供统一的 Hook/Composition API，支持自动重连、消息缓冲、多连接管理和心跳检测。

---

### 核心技术亮点

#### 1. 有限状态机设计 (FSM)

```
None → Inited → Opened → Sent/Received → Closing → Closed
```

- 通过状态机管理 WebSocket 生命周期
- 提供语义化查询方法：`sendable`、`alive`、`closable`
- 防止无效操作（如连接未建立就发送）

#### 2. 智能自动重连机制

- 区分「主动关闭」和「被动断开」：只在网络断开时重连
- 每个 URL 独立的重连定时器，防止重复重连
- 1.2 秒固定重连间隔，简单可靠

#### 3. 伪 Ping-Pong 心跳检测

- **解决的问题：** 浏览器端无法使用 WebSocket 原生 ping-pong
- **方案：** 复用上次发送的业务消息作为心跳包
- 使用 `set-harmonic-interval` 库实现抗抖动定时器

#### 4. 消息发送缓冲 (SendBuffer)

- 连接未就绪时自动缓存消息
- 环形缓冲区设计，最多保存 20 条，防止内存泄漏
- 连接建立后自动 flush 最新消息

#### 5. 多连接管理 (WebSocketHub)

- 支持同时管理多个 WebSocket 连接
- URL 作为 key 的连接池，防止重复连接
- 动态 URL Builder 支持负载均衡

---

### 架构分层

```
┌─────────────────────────────────────────┐
│  useApiWebSocket (高层)                  │
│  - API 动态获取 WebSocket 地址           │
│  - 定时轮询更新连接                       │
└──────────────────┬──────────────────────┘
                   │ 组合
┌──────────────────▼──────────────────────┐
│  useWebSocket (中层)                     │
│  - React/Vue 响应式封装                  │
│  - 生命周期管理                           │
└──────────────────┬──────────────────────┘
                   │ 使用
┌──────────────────▼──────────────────────┐
│  WebSocketHub (核心)                     │
│  - 多连接管理、自动重连                   │
│  - 事件绑定与分发                         │
└──────────────────┬──────────────────────┘
                   │ 管理
┌──────────────────▼──────────────────────┐
│  WSWrapper + SendBuffer (底层)           │
│  - 单连接状态机、消息缓冲、节流发送        │
└─────────────────────────────────────────┘
```

---

### 面试问答准备

**Q1: 为什么要自己封装 WebSocket？**

原生 WebSocket 缺乏：自动重连、消息缓冲、多连接管理、心跳检测。这个库统一解决这些问题，并提供 React/Vue 双框架支持。

**Q2: 如何处理断线重连？**

使用 `_explicitlyClosed` 标志区分主动关闭和被动断开。只在被动断开时触发重连，每个 URL 有独立的重连定时器，防止重复重连。

**Q3: SendBuffer 为什么只发送最新消息而不是全部？**

对于实时数据场景，旧消息已经过时。只发送最新消息减少网络流量，同时避免发送过时请求。这是一个针对业务场景的 trade-off。

**Q4: 为什么用状态机而不是简单的 boolean 标志？**

状态机能表达更丰富的语义（如 Sent vs Received），支持复杂的状态查询组合（`sendable` 需要在 Opened/Sent/Received 三个状态），且便于调试和日志记录。

**Q5: React 和 Vue 代码如何复用？**

核心逻辑（WebSocketHub、WSWrapper）与框架无关，只有顶层 Hook 使用框架特定 API（React 用 useState/useEffect，Vue 用 ref/watch）。

---

主要改动：

1. 统一了标题层级和格式
2. 代码块添加了语言标识
3. 表格对齐优化
4. 架构图用代码块包裹，避免渲染问题
5. 面试话术用加粗标题突出
6. 分隔线让各模块更清晰
7. 问答部分用加粗问题便于快速定位

需要我再调整哪部分吗？

## 业务介绍
 一款智能出行服务平台的乘客端应用，为用户提供
  V2X（车联网）场景下的出行服务。

  业务场景：
  - 乘客通过手机登录，使用自动驾驶/智能网联车辆的出行服务
  - 类似 Robotaxi 乘客端，用户可以叫车、管理个人信息

  目标用户：需要智能出行服务的乘客

  产品定位：SenseAuto 智能出行生态中的 C 端触点

