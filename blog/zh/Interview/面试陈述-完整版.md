

---

## Part 1: 我是谁

### 不是简历上的那个人

如果只看简历，你会看到：4 年前端经验、商汤的工作经历，18 个月的空窗期。

但这些标签不能告诉你我是怎么思考的。

《刻意练习》这本书里有一个概念叫"心理表征"——大师和新手的区别不是记忆力，而是他们看到的模式不同。国际象棋大师看棋盘，看到的不是 32 个棋子的位置，而是一个整体的局势。医生看病人，看到的不是一堆症状，而是一个完整的病理图景。

我觉得学技术也是一样的。语法会过时，框架会迭代，但思维方式是可以迁移的。

入职半年涨薪 50%，后来独立带项目——这些结果证明了这种学习方式是有效的。

---

### 关于八股文

进入这个行业时，我并不知道所谓的"八股文"是什么。我是公司内部测试转岗，团队很了解我，知道我能出活，所以没人质疑我的能力。某种意义上，我是靠"被看见真实能力"进入行业的。

第一次跳槽时，我才意识到外部面试体系完全不同，于是按流程把八股文和 LeetCode 全刷了一遍。

真正的困扰，是我准备从前司再次跳槽时开始的。我突然意识到：**难道我每次跳槽，都要像高考冲刺一样，再来一轮"背题"吗？**

我尝试过重新背，但第二次比第一次更痛苦。第一次很多不懂，学习反而充满新鲜感；第二次明明很多理解了，却依然讲不清——这种"知道但无法表达"的落差更让人沮丧。

后来和两个 CS 科班、985 的后端同事聊过，他们也说背八股文很痛苦，算法不刷就会忘。那一刻我才明白：**这并不是我一个人的问题，是大多数人的状态。**

于是我开始反思：这件事是不是我的路线出了问题？但想了一圈，面试流程本身其实没有错。外部面试官不了解我，他们必须在一小时内判断一个人是否靠谱，最省成本的方式就是八股文加 LeetCode。就像跳槽卡薪资涨幅一样，公司只能根据你的 base 大致推测能力。这些"参考标准"虽然有道理，却不等于合理。

所以我开始问自己一个更根本的问题：**如果我不想每次都以"应试"方式准备面试，那有没有办法在不刷题、不背诵的情况下，让别人依然知道我能出活？**

答案其实很简单：**平时把自己当产品来打磨，把亮点尽可能让别人看到。**

我想起前司领导常说的一句话：要关注自己的 reputation。团队长期合作下来，谁靠谱、谁混日子、谁扛事，其实一清二楚。这就是"品牌形象"。当 reputation 建立起来，好机会自然更容易找到你。

本质上，自媒体、开源、作品集，也都是"产品化自己"的方式。而 AI 的趋势也很明确：**最先被替代的，就是只会死记硬背、重复规则的人。**

---

### 18 个月的空窗期

很多人会问这段经历。我可以给一个"正确"的回答：主动调整、学习充电、思考方向。但这不是全部的真相。

真相是：我当时不会处理压力。

上一份工作离开的直接原因是项目遇到了困难。但根本原因是我把项目的问题等同于"我不行"。这是一种认知扭曲——在心理学里叫"个人化"，就是把外部事件的责任全部归咎于自己。

我花了很长时间才意识到这一点。

这 18 个月里，我读了《伯恩斯情绪疗法》，系统学习了认知行为疗法。我开始能够识别自己的思维陷阱：

- **非黑即白**：要么完美，要么失败，没有中间状态
- **过度泛化**：一次失败就认为自己永远会失败
- **情绪化推理**：因为我感觉自己不行，所以我就是不行
- **应该陈述**：我"应该"做到什么什么，做不到就是失败

这些模式在我身上反复出现。拖延就是一个典型的例子。

我以前以为拖延是懒。后来我发现不是。我只会拖延那些我觉得自己"不擅长"的事情。遇到瓶颈的时候，我倾向于停下来，而不是推过去。

**拖延背后藏着的不是懒，而是对不完美的恐惧。**

理解了这一点之后，我开始允许自己不完美。完美需要太久太久。**开始，比完美更重要。**

---

### 从外部反馈到内部反馈

这段经历还改变了我对"反馈"的理解。

以前我很依赖外部反馈：领导的认可、项目的成功、用户的数据。这些反馈当然重要，但问题是——它们不总是及时的，也不总是准确的。

项目失败可能是因为市场时机不对，不是因为你代码写得烂。领导的批评可能反映的是他的情绪，不是你的能力。

**如果你只依赖外部反馈，你就把自己的情绪交给了你无法控制的东西。**

所以我开始建立内部反馈系统。代码写完了，我会问自己：这段代码比昨天写的更好吗？我学到了什么新东西？我有没有在思考，还是只是在机械地敲键盘？

这种转变让我更稳定了。外部世界会波动，但内部的标准是我自己定的。

---

## Part 2: AI 时代的工作方式

### 便捷陷阱

我每天都用 AI 编程工具。Claude Code、GPT，都用。用多了之后，我发现了一个问题。

我把它叫做"便捷陷阱"。

当 Claude Code 在执行任务的时候，它会暂停下来让我确认计划。这个暂停本来是好意——让人类审核 AI 的决策。但实际上发生的是：我会在等待的时候刷手机、看消息、切换到别的窗口。

等我切回来，Claude 的计划已经生成好了。我快速扫一眼，点确认。然后继续等。继续刷手机。

几轮下来，我发现一个问题：我根本没有在思考。

**当工具让事情变得毫不费力，人就会停止专注。**

《刻意练习》这本书里有一句话："如果你的思绪在游荡，或者你只是在放松地玩，你很可能不会进步。"

这正是我在用 AI 工具时发生的事情。我以为自己在高效工作，其实我在训练自己的注意力变得更分散。

更可怕的是，这种模式会累积。如果我们持续被打断、持续不愿意慢下来真正吸收某些东西，那么几年之后，我们还有能力进行深度思考吗？

---

### 我的应对系统

意识到这个问题之后，我开始建立系统来对抗它。

我写了一个双维度的日志系统。每次启动 Claude Code 任务，系统会自动记录：时间、项目、任务描述。任务结束后，会自动提取 Claude 的总结，追加到日志里。

这个系统有两个维度：

**时间维度**：按天记录。我今天做了什么、花了多少时间、Claude 给出了什么结论。这让我可以快速回顾"今天干了什么"。

**项目维度**：按项目记录。这个项目从开始到现在，经历了哪些任务、做了哪些决策。当几周后出现一个奇怪的 bug，我可以回溯当时的上下文。

这个系统的核心不是"记录"，而是"强迫思考"。

当我知道每个决策都会被记录下来，我就不会那么随意地点确认了。当我知道一周后我会回看这些记录，我就会更认真地审核 Claude 的计划。

工具只是工具。它能做的只是记录和整理。真正的改变来自于：意识到问题的存在、主动建立结构来应对、定期审视这些记录。

---

### AI 协作中踩过的坑

在日常使用 Claude Code 的过程中，我也踩过不少坑。这些经历让我更深刻地理解了人和 AI 协作的边界。

**第一个坑：类型定义到处重复。**

我有个前后端一体的 Monorepo 项目，理论上接口类型应该共用一份。但让 Claude Code 做完整的前后端功能时，它会在前端和后端各生成一份类型定义。后面改需求的时候，我得改好几个地方，而且 AI 经常改漏。

后来我跟它约定了规范：定义核心 CoreType 放在公共包里，前后端各自继承补充。但我犯了一个错——没有及时把这个约定写进 `CLAUDE.md`，结果过几天又出现类似问题。

**教训：跟 AI 达成的任何约定，必须马上文档化。**

**第二个坑：本地能跑，部署就炸。**

我在把 Express 和 Next.js 合并进 Turborepo 的时候，跟 AI 说想把长时服务单独部署。AI 看起来帮我做完了，本地测试也能跑通。但一部署就出问题——它把邮件同步写在了 Next.js 的 API Routes 里，而我的前端部署在 Vercel，那是 Serverless 环境，不支持长连接。

这件事让我意识到：**AI 永远给你正反馈**。它不会主动说"这个方案有问题"，只会说"好的，帮你做完了"。等你踩坑了，它才说"哦，这里我没考虑到"。

**第三个坑：遇到错误无脑重试。**

有一次构建失败，AI 执行 `yarn build` 报错说 `dist/` 目录不存在。然后它就开始连续重试同样的命令，试了四五次，每次都是同样的错误。它不会停下来分析：为什么 build 之后 dist 目录没生成？

**第四个坑：头痛医头，不看全局。**

Render 部署失败，报错说 `sharp` 需要 `node-gyp`。AI 的第一反应是在根目录加上 `node-gyp` 依赖。我问了一句"后端服务为什么需要 sharp"，它一查才发现 `sharp` 是 Next.js 的图片优化依赖，后端根本不需要。真正的问题是 `render.yaml` 里的 `yarn install` 会安装整个 Monorepo 的依赖。

**第五个坑：用「偷懒方案」绕过问题。**

AI 有两个危险的习惯：一是遇到 ESLint 报错就 disable，不去分析依赖数组该怎么写；二是为了让构建通过，把敏感信息硬编码。正确做法应该是构建时检查环境变量，缺失就报错，而不是用默认值蒙混过关。

---

### 反思：上下文的传递

这些坑表面上看是 AI 的问题，但反过来想，**核心其实是我没把上下文传递清楚**。

用好 AI 最关键的一点，就是要把自己的上下文尽可能无 Gap 地提供给它——需求背景、技术约束、部署环境这些，你脑子里觉得"这不是显而易见的吗"，但 AI 不知道。

而**「组织上下文」这件事本身就是一个能力**，我觉得很多人其实不太擅长，包括我自己。前面踩的坑，本质上就是我没把隐性知识显性化——没说清楚部署环境是 Serverless，没及时把约定写成文档。

这个能力不光是跟 AI 协作需要，跟人协作也一样。我自己在这方面还在刻意练习，比如现在会把思考过程、做过的决策、踩过的坑都记录下来。这样不管是给 AI 还是给未来的自己，上下文都更完整。

---

### AI 该做什么，人该做什么

我有一个原则：**AI 应该自动化重复性工作，而不是替代深度思考。**

举个例子。我之前要在微信公众号发文章，每次都要花半小时手动调格式。这是典型的重复性工作。我用 Claude Code 写了一个 Markdown 转 HTML 的工具，左边粘贴 Markdown，右边实时预览，一键复制到微信编辑器。

这就是 AI 该做的事情：把我从繁琐的格式调整中解放出来，让我可以专注于写作本身。

但是——写什么、怎么表达、用什么样的情感——这些是 AI 替代不了的。AI 可以给你一个通顺的句子，但它不知道你想传达什么。

我用 AI 的方式是：让它处理我不想花时间的事情，但保留那些需要判断力的事情给自己。

还有一个很重要的点：**AI 有上下文局限。**

AI 写的代码可能在当前 prompt 的范围内是最优解，但它不知道这个项目的历史、不知道之前踩过的坑、不知道团队的约定。这就是"Context Gap"——人和 AI 之间的信息差距。

这个 Gap 必须由人主动去缩减。你需要告诉 AI 足够的上下文，你需要审核它的输出是否符合项目的整体方向，你需要在它犯错的时候纠正它。

AI 是当今世界大家共同的知识图谱。但怎么关联这些知识、怎么应用到具体场景，还是要靠自己。

---

### 一个具体的例子：Git Worktree 自动化

我来讲一个具体的例子，说明我是怎么用 AI 的。

Git Worktree 是一个可以同时在多个分支工作的功能。但原生命令很长：

```bash
git worktree add ../project-feature-a -b feature-a
```

而且每次创建新的 worktree，`.env.local` 不会自动同步过去（因为它在 gitignore 里），我得手动复制。

这是典型的重复性摩擦。我用 Claude Code 写了一个脚本来解决它。

**V1**：自动检测主 worktree 的位置，创建新 worktree 后自动复制 `.env.local`。

**V2**：简化命令。我发现分支名和路径名通常是一样的，所以我做了一个单参数模式：`git wt feat-A` 会自动展开成完整的路径和分支名。输入量减少了 70%。

**V3**：支持 Git Flow 风格的分支命名。`feat/like-button` 这种带斜杠的分支名在文件系统里会有问题，所以脚本会自动把斜杠转成横杠作为路径名，但保留原始分支名。

**V4**：视觉指示器。当我同时跑好几个 worktree 的时候，不知道哪个浏览器窗口对应哪个分支。我在 `next.config.js` 里注入了当前分支名，开发环境下会在页面右下角显示。

每次迭代都是因为实际使用中发现了新的痛点。AI 帮我写代码，但发现问题、定义需求是我自己做的。

这就是我理解的人和 AI 的分工：**AI 执行，人决策。**

---

## Part 3: 审美与产品直觉

### 设计不是炫技

我读过原研哉的《设计中的设计》和《Ex-Formation》。有几句话对我影响很深。

第一句：**"知道是想象的起点，而非终点。"**

如果对话中充斥着"我知道"，正说明我们在不知不觉间脱离了把知识升华为想象的轨道，使思考的列车停了下来。

这句话改变了我对"学习"的理解。很多人学东西是为了"知道"，知道了就觉得完成了。但真正的学习是从"知道"开始的——知道之后才能想象，想象之后才能创造。

第二句：**"创意不是让人惊讶于它崭新的形式和素材，而应该让人惊讶于它居然来自看似平凡的日常生活。"**

好的设计不是炫技。好的设计是在平凡中发现价值。

这也是我做技术决策的原则。我的个人博客没有用复杂的后台系统，就是 Obsidian 写、Git 同步、GitHub API 拉取、前端渲染。

为什么？因为 Obsidian 的编辑体验已经很好了，我没必要重复造轮子。GitHub 已经是一个很好的存储和版本管理系统，我没必要再搭一个数据库。

简单的方案往往是最好的方案。

---

### 慢幸福 vs 多巴胺

前段时间我去看了常玉的展览。展览入口有一句话："阅读是人生最重要的一件事……文学阅读、音乐阅读，或艺术上的阅读。"

这句话改变了我整个看展的状态。我不是在"消费"一个展览，我是在"阅读"一个艺术家。

展览里有一个用 AI 技术做的互动装置，把常玉画的猫做成了 3D 动画。扁平的油画猫变成了会动的、会看你的猫。

那一刻我在想：常玉画这只猫的时候，他脑子里看到的是不是就是这样的？AI 没有替代艺术，它让我更接近了艺术家当时的视角。

看完展览，我有一个很强烈的感受：**我越来越喜欢这种缓慢的幸福，而不是把兴奋误认为幸福。**

过甜的蛋糕，第一口会让你很兴奋，但吃完会觉得腻。略带甜味的茶，第一口不会让你惊艳，但余韵是悠长的。

我现在更喜欢后者。

---

### 社交媒体的身份陷阱

有一次朋友说我的背包"班味很重"。这句话让我想了很久。

我们买东西，到底是因为需要，还是因为它代表的身份？

小红书每隔几年会流行一些"生活方式"：露营、徒步、滑雪、citywalk。朋友圈里大家同步地参加音乐节、同步地去打卡网红餐厅。

这些是爱好吗？还是欲望伪装成了爱好？

我不是说这些活动本身有问题。问题是：**如果没有小红书、没有朋友圈，这些"爱好"还会存在吗？**

现在几乎所有的 App 都在加社交功能。微信读书有阅读时长排名，有人为了排名会挂机放书。读书变成了表演，而不是真正的阅读。

我们在乎的不是活动本身，而是这些活动给我们贴的标签。

我对这种现象是警惕的。我希望我做一件事是因为我真的想做，而不是因为它能让我看起来像某种人。

---

### Hygge：舒适感的设计

我读过一本丹麦人写的书，叫《为什么我只想呆在家》。丹麦语里有一个词叫 hygge，大概意思是"舒适的幸福感"。

书里有一些有意思的观点：

- 自然光可以让房间感觉更大，也能预防抑郁。世卫组织的研究显示，缺乏日照会增加 60% 的抑郁风险。
- 角落里的一盏灯比头顶的大灯更有温暖感。它在说"来沙发上看书吧"。
- 我们买东西往往是基于幻想，而不是真实需求。便宜的快乐很快会被遗忘，便宜的痛苦却会持续很久。

有一个观点我特别喜欢：**当所有人都能在家里感到满足、不想出门消费的时候，资本主义就受到了威胁。**

舒服地呆在家里，本身就是一种对消费主义的抵抗。

---

## Part 4: 为什么是这份工作

### 交汇点

这个岗位要求的是"有产品能力、有审美、懂用户思维的前端"。

我觉得这正好是我这段时间积累的方向。

我有技术能力。分片上传、WebSocket 封装、邮件同步系统——这些项目证明我可以独立完成复杂的技术方案。

我有产品思维。我的博客架构不是从"我要用什么技术"出发的，而是从"我不想重复造后台编辑器"这个问题出发的。Git Worktree 脚本的四次迭代，每次都是因为实际使用中发现了新的痛点。

我有审美和用户思维。原研哉教会我"设计是在平凡中发现价值"。常玉的展览让我理解了"慢幸福"。对社交媒体的反思让我能够区分"真实需求"和"伪装成需求的欲望"。

我对 AI 工具的批判性思考，本质上就是在用同理心理解用户。当工具让事情变得太容易，用户会停止思考——这是一个用户体验的问题，不只是技术问题。

这些能力是在过去 18 个月里积累起来的。Gap 不是空白，是我换一种方式在成长。

---

### 薪资

最后聊一下薪资。

我想坦诚地说：我有一段职业空白期，但这段时间我没有停下来。我一直在学习、在思考。我不觉得这是减分项，反而让我更清楚自己想要什么。

正因为我不着急，我更希望找到一个真正想长期投入的地方。我不想入职之后还在看别的机会，那对双方都是消耗。

我也知道我身上有一些标签——女性、有 gap。市场上可能会有人因为这些标签先打个问号。但正因为这样，我更不想让自己的表现给这些标签抹黑。我希望我做得好，能让别人以后看到类似背景的人时，少一点偏见。

所以薪资这件事，我想认真争取一下。

**你们能给到什么是一回事，我有没有为自己开口是另一回事。**

我不想因为这是我 gap 之后的第一个机会，就不敢表达我的期望——那和过去的我没有区别。

如果我对自己都没有信心，我也没法让你们对我有信心。

**我不想先说一个数字把自己框住。我更想知道，你们评估下来觉得我值多少。**

我希望薪资是一个让我安心投入的起点。

---

## 附：核心观点速览

1. **拖延背后藏着的不是懒，而是对不完美的恐惧。**
    
2. **当工具让事情变得毫不费力，人就会停止专注。**
    
3. **AI 应该自动化重复性工作，而不是替代深度思考。**
    
4. **用好 AI 的关键是提供无 Gap 的上下文——这本身就是一种能力。**
    
5. **知道是想象的起点，而非终点。**
    
6. **好的设计不是炫技，而是在平凡中发现价值。**
    
7. **我越来越喜欢缓慢的幸福，而不是把兴奋误认为幸福。**
    
8. **完美需要太久太久。开始，比完美更重要。**
    
9. **最先被 AI 替代的，是只会死记硬背的人。**
    
10. **人需要自谦，但不应该自卑。**
    

---

需要我帮你保存到 Obsidian 吗？